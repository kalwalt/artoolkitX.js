<html>
<body>
	<script type='text/javascript'>
	window.artoolkitX_wasm_url = '../SDK/lib/artoolkitx.wasm';
	</script>
<script src="js/three.min.js"></script>
<script type="module" src="../SDK/lib/artoolkitX.api.js"></script>



<video id="v" src="Data/output_4.mp4" width="320" height="240" loop="" controls="" autoplay webkit-playsinline></video>

<script id="vert" type="glsl-vertex">
precision highp float;
precision lowp int;

uniform mat4 cameraMatrix;
uniform mat4 transformationMatrix;

varying vec2 vUv;

void main(void)
{
	vUv = uv;
	gl_Position = cameraMatrix * transformationMatrix * vec4(position, 1.0);
}
</script>

<script id="frag" type="glsl-fragment">
precision highp float;
precision lowp int;

varying vec2 vUv;

void main(void)
{
	gl_FragColor = vec4(vUv, 1.0, 1.0);
}
</script>

<script type="module">
import ARController from '../SDK/lib/artoolkitX.api.js';

const cameraParam = './Data/camera_para.dat';

const config = {
    cameraParam: cameraParam,
    width: 640,
    height: 480
};

var trackable = {
    trackableType: "single_barcode",
    barcodeId: 1
}

var ar1, interval;

var cMat = new THREE.Matrix4();
var tMat = new THREE.Matrix4();

var USE_SHADER = true;

var shaderMaterial = new THREE.ShaderMaterial({
	uniforms: {
		cameraMatrix: {type: 'm4', value: cMat },
		transformationMatrix: {type: 'm4', value: tMat }
	},
	vertexShader: vert.text,
	fragmentShader: frag.text
});


var renderer = new THREE.WebGLRenderer();
var scene = new THREE.Scene();

renderer.setSize(v.width, v.height);

document.body.appendChild(renderer.domElement);

// Create a camera and a marker root object for your Three.js scene.
var camera = new THREE.Camera();
scene.add(camera);


var light = new THREE.PointLight(0xffffff);
light.position.set(400, 500, 100);
scene.add(light);
var light = new THREE.PointLight(0xffffff);
light.position.set(-400, -500, -100);
scene.add(light);

var markerRoot = new THREE.Object3D();

markerRoot.wasVisible = false;
markerRoot.markerMatrix = new Float64Array(16);
markerRoot.matrixAutoUpdate = false;
camera.matrixAutoUpdate = false;

// Add the marker models and suchlike into your marker root object.

var cube = new THREE.Mesh(
	new THREE.BoxGeometry(1,1,1),
	USE_SHADER ?
		shaderMaterial :
		new THREE.MeshLambertMaterial({ color: 0xffffff, wireframe: false })
);
markerRoot.add(cube);

// Add the marker root to your scene.
scene.add(markerRoot);


var video = document.getElementById('v');
var arController = new ARController(video, cameraParam);
//var trackableInfo;

window.addEventListener('artoolkitX-loaded', () => {
var camera_mat = new Float64Array(16);
	arController.addEventListener('getMarker', (trackableInfo) => {
			console.log("TrackableID: " + trackableInfo.data.trackableId);
			//console.log(trackableInfo.data.transformation);
	});

	try {
			//arController.setLogLevel(1);
			arController.start().then( () => {
					console.log("start done");
					var trackableId = arController.addTrackable(trackable);
					interval = setInterval(function() {

							arController.process(video);
							arController.getCameraMatrix(0.0, 1000.0, camera_mat);
					}, 13);
					ar1 = arController;

			});

	}
	catch (e) {
			console.log(e);
	}

// On every frame do the following:
function tick() {
	requestAnimationFrame(tick);

	if (!arController) {
		return;
	}

	//var markerNum = arController.getMarkerNum();
	var markerNum=1;
	if (markerNum > 0) {

		markerRoot.visible = true;
		if (USE_SHADER) {
					shaderMaterial.uniforms.transformationMatrix.value.elements = arController.getTransformationData(0);
		} else {
					markerRoot.matrix.elements = arController.getTransformationData(0);
				}

	} else {
		markerRoot.visible = false;
	}

	if (USE_SHADER) {
		shaderMaterial.uniforms.cameraMatrix.value.fromArray(camera_mat);
	} else {
		camera.projectionMatrix.fromArray(camera_mat);
	}
}

	// Render the scene.
	renderer.autoClear = false;
	renderer.clear();
	renderer.render(scene, camera);

	tick();

	arController.debugSetup();
});

</script>

</body>
</html>
